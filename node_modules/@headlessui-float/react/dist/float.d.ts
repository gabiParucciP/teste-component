import type { CSSProperties, Dispatch, ElementType, MutableRefObject, ReactElement, SetStateAction } from 'react';
import { type ExtendedRefs } from '@floating-ui/react';
import type { AutoPlacementOptions, FlipOptions, HideOptions, OffsetOptions, ShiftOptions } from '@floating-ui/core';
import type { AutoUpdateOptions, DetectOverflowOptions, Middleware, Placement, Strategy, VirtualElement } from '@floating-ui/dom';
import type { ClassResolver } from './class-resolvers';
interface ReferenceState {
    referenceRef: (node: HTMLElement) => void;
    placement: Placement;
}
interface FloatingState {
    floatingRef: (node: HTMLElement) => void;
    props: Omit<FloatProps, 'children' | 'className'>;
    mounted: MutableRefObject<boolean>;
    setShow: Dispatch<SetStateAction<boolean>>;
    referenceHidden: boolean | undefined;
    escaped: boolean | undefined;
    placement: Placement;
    floatingStyles: CSSProperties;
    referenceElWidth: number | null;
}
export interface FloatProps {
    as?: ElementType;
    floatingAs?: ElementType;
    show?: boolean;
    placement?: Placement;
    strategy?: Strategy;
    offset?: OffsetOptions;
    shift?: boolean | number | Partial<ShiftOptions & DetectOverflowOptions>;
    flip?: boolean | number | Partial<FlipOptions & DetectOverflowOptions>;
    arrow?: boolean | number;
    autoPlacement?: boolean | Partial<AutoPlacementOptions & DetectOverflowOptions>;
    hide?: boolean | Partial<HideOptions & DetectOverflowOptions> | Partial<HideOptions & DetectOverflowOptions>[];
    referenceHiddenClass?: string;
    escapedClass?: string;
    autoUpdate?: boolean | Partial<AutoUpdateOptions>;
    zIndex?: number | string;
    enter?: string;
    enterFrom?: string;
    enterTo?: string;
    leave?: string;
    leaveFrom?: string;
    leaveTo?: string;
    originClass?: string | ClassResolver;
    tailwindcssOriginClass?: boolean;
    portal?: boolean;
    transform?: boolean;
    adaptiveWidth?: boolean | {
        attribute?: string;
    };
    composable?: boolean;
    dialog?: boolean;
    middleware?: Middleware[] | ((refs: {
        referenceEl: MutableRefObject<Element | VirtualElement | null>;
        floatingEl: MutableRefObject<HTMLElement | null>;
    }) => Middleware[]);
    className?: string | ((bag: FloatReferenceRenderProp) => string);
    children: ReactElement[] | ((slot: FloatReferenceRenderProp) => ReactElement[]);
    onShow?: () => void;
    onHide?: () => void;
    onUpdate?: () => void;
}
export declare function renderReferenceElement(ReferenceNode: ReactElement, componentProps: FloatReferenceProps & Required<Pick<FloatReferenceProps, 'as'>>, { key, ...attrs }: Record<string, any>, context: ReferenceState): import("react/jsx-runtime").JSX.Element;
export type RenderFloatingElementProps = FloatContentProps & Required<Pick<FloatContentProps, 'as'>> & {
    show?: boolean | null;
};
export declare function renderFloatingElement(FloatingNode: ReactElement, componentProps: RenderFloatingElementProps, { key, ...attrs }: Record<string, any>, context: FloatingState): import("react/jsx-runtime").JSX.Element;
export interface FloatRenderProp {
    placement: Placement;
}
export interface FloatReferenceProps extends Pick<FloatProps, 'as'> {
    className?: string | ((bag: FloatReferenceRenderProp) => string);
    children?: ReactElement | ((slot: FloatReferenceRenderProp) => ReactElement);
}
export interface FloatReferenceRenderProp {
    placement: Placement;
}
declare function Reference(props: FloatReferenceProps): import("react/jsx-runtime").JSX.Element;
export interface FloatContentProps extends Pick<FloatProps, 'as' | 'enter' | 'enterFrom' | 'enterTo' | 'leave' | 'leaveFrom' | 'leaveTo' | 'originClass' | 'tailwindcssOriginClass'> {
    transitionChild?: boolean;
    className?: string | ((bag: FloatContentRenderProp) => string);
    children?: ReactElement | ((slot: FloatContentRenderProp) => ReactElement);
}
export interface FloatContentRenderProp {
    placement: Placement;
}
declare function Content(props: FloatContentProps): import("react/jsx-runtime").JSX.Element;
export interface FloatArrowProps extends Pick<FloatProps, 'as'> {
    offset?: number;
    className?: string | ((bag: FloatArrowRenderProp) => string);
    children?: ReactElement | ((slot: FloatArrowRenderProp) => ReactElement);
}
export interface FloatArrowRenderProp {
    placement: Placement;
}
declare function Arrow(props: FloatArrowProps): import("react/jsx-runtime").JSX.Element;
export interface FloatVirtualProps extends Pick<FloatProps, 'as' | 'show' | 'placement' | 'strategy' | 'offset' | 'shift' | 'flip' | 'arrow' | 'autoPlacement' | 'autoUpdate' | 'zIndex' | 'enter' | 'enterFrom' | 'enterTo' | 'leave' | 'leaveFrom' | 'leaveTo' | 'originClass' | 'tailwindcssOriginClass' | 'portal' | 'transform' | 'middleware' | 'onShow' | 'onHide' | 'onUpdate'> {
    onInitial: (props: FloatVirtualInitialProps) => void;
    className?: string;
    children?: ReactElement | ((slot: FloatVirtualRenderProp) => ReactElement);
}
export interface FloatVirtualInitialProps {
    show: boolean;
    setShow: Dispatch<SetStateAction<boolean>>;
    placement: Placement;
    refs: ExtendedRefs<HTMLElement>;
}
export interface FloatVirtualRenderProp {
    placement: Placement;
    close: () => void;
}
declare function Virtual({ onInitial, children, ...props }: FloatVirtualProps): import("react/jsx-runtime").JSX.Element;
export interface FloatContextMenuProps extends Omit<FloatVirtualProps, 'show' | 'portal' | 'onInitial'> {
}
declare function ContextMenu(props: FloatContextMenuProps): import("react/jsx-runtime").JSX.Element;
export interface FloatCursorProps extends Omit<FloatVirtualProps, 'show' | 'portal' | 'onInitial'> {
    globalHideCursor?: boolean;
}
declare function Cursor({ globalHideCursor, ...props }: FloatCursorProps): import("react/jsx-runtime").JSX.Element;
export declare const Float: import("react").ForwardRefExoticComponent<FloatProps & import("react").RefAttributes<ElementType>> & {
    Reference: typeof Reference;
    Content: typeof Content;
    Arrow: typeof Arrow;
    Virtual: typeof Virtual;
    ContextMenu: typeof ContextMenu;
    Cursor: typeof Cursor;
};
export {};
